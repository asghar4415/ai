{
    "Paper B - Panelist Seating CSP": {
        "prefix": "panelist_seating",
        "body": [
            "from ortools.sat.python import cp_model",
            "",
            "def solve_panelist_seating():",
            "    # Create model",
            "    model = cp_model.CpModel()",
            "    ",
            "    # Panelists and seats",
            "    panelists = ['Amir', 'Bella', 'Charles', 'Diana', 'Ethan', 'Farah']",
            "    num_seats = 6",
            "    seats = list(range(num_seats))",
            "    ",
            "    # Create variables: seat[i] represents which panelist sits there",
            "    seating = {}",
            "    for seat in seats:",
            "        seating[seat] = model.NewIntVar(0, len(panelists)-1, f'seat_{seat}')",
            "    ",
            "    # Add constraints",
            "    # 1. All panelists must be in different seats",
            "    model.AddAllDifferent([seating[seat] for seat in seats])",
            "    ",
            "    # 2. Bella must be left of Farah",
            "    bella = panelists.index('Bella')",
            "    farah = panelists.index('Farah')",
            "    for i in seats:",
            "        for j in seats:",
            "            if i >= j:",
            "                model.Add(seating[i] != bella).OnlyEnforceIf(seating[j] == farah)",
            "    ",
            "    # 3. Charles must sit next to Diana",
            "    charles = panelists.index('Charles')",
            "    diana = panelists.index('Diana')",
            "    adjacent_pairs = []",
            "    for i in range(num_seats - 1):",
            "        adjacent_pairs.append((i, i+1))",
            "    for i in range(1, num_seats):",
            "        adjacent_pairs.append((i, i-1))",
            "    ",
            "    adjacent_constraints = []",
            "    for i, j in adjacent_pairs:",
            "        is_adjacent = model.NewBoolVar(f'adjacent_{i}_{j}')",
            "        model.Add(seating[i] == charles).OnlyEnforceIf(is_adjacent)",
            "        model.Add(seating[j] == diana).OnlyEnforceIf(is_adjacent)",
            "        adjacent_constraints.append(is_adjacent)",
            "    model.Add(sum(adjacent_constraints) >= 1)",
            "    ",
            "    # 4. Amir cannot sit at ends",
            "    amir = panelists.index('Amir')",
            "    model.Add(seating[0] != amir)",
            "    model.Add(seating[5] != amir)",
            "    ",
            "    # 5. Ethan must be in middle (seat 2 or 3)",
            "    ethan = panelists.index('Ethan')",
            "    model.Add(seating[2] == ethan).OnlyEnforceIf(model.NewBoolVar('ethan_seat2'))",
            "    model.Add(seating[3] == ethan).OnlyEnforceIf(model.NewBoolVar('ethan_seat3'))",
            "    model.AddBoolOr([seating[2] == ethan, seating[3] == ethan])",
            "    ",
            "    # 6. Diana cannot sit at ends",
            "    model.Add(seating[0] != diana)",
            "    model.Add(seating[5] != diana)",
            "    ",
            "    # Solve the model",
            "    solver = cp_model.CpSolver()",
            "    status = solver.Solve(model)",
            "    ",
            "    # Print solution",
            "    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:",
            "        print(\"Optimal seating arrangement:\")",
            "        for seat in seats:",
            "            panelist_index = solver.Value(seating[seat])",
            "            print(f\"Seat {seat}: {panelists[panelist_index]}\")",
            "        ",
            "        # Verify constraints",
            "        print(\"\\nConstraint Verification:\")",
            "        seating_arrangement = [panelists[solver.Value(seating[seat])] for seat in seats]",
            "        ",
            "        # 1. All different",
            "        print(f\"- All panelists unique: {len(set(seating_arrangement)) == len(panelists)}\")",
            "        ",
            "        # 2. Bella left of Farah",
            "        bella_pos = seating_arrangement.index('Bella')",
            "        farah_pos = seating_arrangement.index('Farah')",
            "        print(f\"- Bella left of Farah: {bella_pos < farah_pos}\")",
            "        ",
            "        # 3. Charles next to Diana",
            "        charles_pos = seating_arrangement.index('Charles')",
            "        diana_pos = seating_arrangement.index('Diana')",
            "        print(f\"- Charles next to Diana: {abs(charles_pos - diana_pos) == 1}\")",
            "        ",
            "        # 4. Amir not at ends",
            "        print(f\"- Amir not at ends: {'Amir' not in [seating_arrangement[0], seating_arrangement[5]]}\")",
            "        ",
            "        # 5. Ethan in middle",
            "        print(f\"- Ethan in middle: {seating_arrangement[2] == 'Ethan' or seating_arrangement[3] == 'Ethan'}\")",
            "        ",
            "        # 6. Diana not at ends",
            "        print(f\"- Diana not at ends: {'Diana' not in [seating_arrangement[0], seating_arrangement[5]]}\")",
            "        ",
            "        print(f\"\\nSolver status: {'Optimal' if status == cp_model.OPTIMAL else 'Feasible'} solution found\")",
            "    else:",
            "        print(\"No solution found\")",
            "",
            "solve_panelist_seating()"
        ],
        "description": "Solution for Paper B Q1 - Panelist Seating CSP Problem"
    },
    "Paper B - Amazon B2B Classification": {
        "prefix": "amazon_b2b",
        "body": [
            "import pandas as pd",
            "import numpy as np",
            "from sklearn.model_selection import train_test_split, cross_val_score, KFold",
            "from sklearn.preprocessing import StandardScaler, LabelEncoder, OneHotEncoder",
            "from sklearn.ensemble import RandomForestClassifier",
            "from sklearn.svm import SVC",
            "from sklearn.linear_model import LogisticRegression",
            "from sklearn.metrics import classification_report, confusion_matrix, accuracy_score",
            "from sklearn.impute import SimpleImputer",
            "from sklearn.compose import ColumnTransformer",
            "from sklearn.pipeline import Pipeline",
            "",
            "def amazon_sale_analysis():",
            "    # Part 1: Data Pre-processing",
            "    try:",
            "        df = pd.read_csv('amazon_sales.csv')",
            "    except FileNotFoundError:",
            "        print(\"Error: File 'amazon_sales.csv' not found\")",
            "        return",
            "    ",
            "    # Handle missing values",
            "    X = df.drop('B2B', axis=1)",
            "    y = df['B2B']",
            "    ",
            "    # Identify categorical and numerical columns",
            "    categorical_cols = X.select_dtypes(include=['object', 'category']).columns",
            "    numerical_cols = X.select_dtypes(include=['int64', 'float64']).columns",
            "    ",
            "    # Create preprocessing pipelines",
            "    numerical_transformer = Pipeline(steps=[",
            "        ('imputer', SimpleImputer(strategy='mean')),",
            "        ('scaler', StandardScaler())])",
            "    ",
            "    categorical_transformer = Pipeline(steps=[",
            "        ('imputer', SimpleImputer(strategy='most_frequent')),",
            "        ('onehot', OneHotEncoder(handle_unknown='ignore'))])",
            "    ",
            "    preprocessor = ColumnTransformer(",
            "        transformers=[",
            "            ('num', numerical_transformer, numerical_cols),",
            "            ('cat', categorical_transformer, categorical_cols)])",
            "    ",
            "    # Part 2: Data Splitting and Model Training",
            "    X_train, X_test, y_train, y_test = train_test_split(",
            "        X, y, test_size=0.2, random_state=42)",
            "    ",
            "    # Define models",
            "    models = {",
            "        'Random Forest': RandomForestClassifier(random_state=42),",
            "        'SVM': SVC(kernel='rbf', probability=True, random_state=42),",
            "        'Logistic Regression': LogisticRegression(max_iter=1000, random_state=42)",
            "    }",
            "    ",
            "    # Train and evaluate models",
            "    for name, model in models.items():",
            "        pipeline = Pipeline(steps=[('preprocessor', preprocessor),",
            "                                 ('model', model)])",
            "        pipeline.fit(X_train, y_train)",
            "        models[name] = pipeline",
            "    ",
            "    # Part 3: Model Evaluation",
            "    print(\"\\nTest Set Performance:\")",
            "    for name, model in models.items():",
            "        y_test_pred = model.predict(X_test)",
            "        print(f\"\\n{name}:\")",
            "        print(\"Accuracy:\", accuracy_score(y_test, y_test_pred))",
            "        print(\"Confusion Matrix:\")",
            "        print(confusion_matrix(y_test, y_test_pred))",
            "        print(\"Classification Report:\")",
            "        print(classification_report(y_test, y_test_pred))",
            "    ",
            "    # Cross-validation",
            "    kfold = KFold(n_splits=5, shuffle=True, random_state=42)",
            "    for name, model in models.items():",
            "        cv_scores = cross_val_score(model, X, y, cv=kfold, scoring='accuracy')",
            "        print(f\"\\n{name} CV Accuracy: {np.mean(cv_scores):.3f} (±{np.std(cv_scores):.3f})\")",
            "    ",
            "    return max(models.keys(), key=lambda x: accuracy_score(y_test, models[x].predict(X_test)))",
            "",
            "best_model = amazon_sale_analysis()"
        ],
        "description": "Solution for Paper B Q2 - Amazon B2B Classification"
    },
    "Paper A - Bin Packing CSP": {
        "prefix": "bin_packing",
        "body": [
            "from ortools.sat.python import cp_model",
            "",
            "def solve_bin_packing():",
            "    # Create model",
            "    model = cp_model.CpModel()",
            "    ",
            "    # Items and bins",
            "    item_weights = [4, 8, 1, 4, 2, 6, 3, 5]",
            "    num_items = len(item_weights)",
            "    bins = [0, 1, 2]",
            "    bin_capacity = 12",
            "    ",
            "    # Create variables",
            "    assignment = {}",
            "    for i in range(num_items):",
            "        assignment[i] = model.NewIntVar(0, len(bins)-1, f'item_{i}_bin')",
            "    ",
            "    # Create bin loads variables",
            "    bin_loads = {}",
            "    for b in bins:",
            "        bin_loads[b] = model.NewIntVar(0, bin_capacity, f'bin_{b}_load')",
            "    ",
            "    # Add constraints",
            "    for b in bins:",
            "        model.Add(",
            "            sum(item_weights[i] * (assignment[i] == b) for i in range(num_items)) <= bin_capacity",
            "        )",
            "    ",
            "    # Specific constraints",
            "    model.Add(assignment[2] != assignment[1])  # Items 2 and 1 in different bins",
            "    model.Add(assignment[0] == assignment[5])  # Items 0 and 5 in same bin",
            "    model.Add(assignment[4] != assignment[5])  # Items 4 and 5 in different bins",
            "    model.Add(assignment[6] == assignment[7])  # Items 6 and 7 in same bin",
            "    model.Add(assignment[6] != assignment[1])  # Items 6/7 not with item 1",
            "    model.Add(assignment[5] != 0)  # Item 5 not in bin 0",
            "    ",
            "    # Solve the model",
            "    solver = cp_model.CpSolver()",
            "    status = solver.Solve(model)",
            "    ",
            "    # Print solution",
            "    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:",
            "        print(\"Optimal item assignment:\")",
            "        bin_contents = {b: [] for b in bins}",
            "        bin_weights = {b: 0 for b in bins}",
            "        ",
            "        for i in range(num_items):",
            "            b = solver.Value(assignment[i])",
            "            bin_contents[b].append(i)",
            "            bin_weights[b] += item_weights[i]",
            "        ",
            "        for b in bins:",
            "            print(f\"Bin {b}: Items {bin_contents[b]} (Total weight: {bin_weights[b]})\")",
            "        ",
            "        # Verify constraints",
            "        assignments = [solver.Value(assignment[i]) for i in range(num_items)]",
            "        print(\"\\nConstraint Verification:\")",
            "        print(\"- All bin weights ≤ 12:\", all(w <= bin_capacity for w in bin_weights.values()))",
            "        print(\"- Items 2 and 1 different bins:\", assignments[2] != assignments[1])",
            "        print(\"- Items 0 and 5 same bin:\", assignments[0] == assignments[5])",
            "        print(\"- Items 4 and 5 different bins:\", assignments[4] != assignments[5])",
            "        print(\"- Items 6 and 7 same bin:\", assignments[6] == assignments[7])",
            "        print(\"- Items 6 and 7 not with item 1:\", assignments[6] != assignments[1])",
            "        print(\"- Item 5 not in bin 0:\", assignments[5] != 0)",
            "        ",
            "        print(f\"\\nSolver status: {'Optimal' if status == cp_model.OPTIMAL else 'Feasible'} solution found\")",
            "    else:",
            "        print(\"No solution found\")",
            "",
            "solve_bin_packing()"
        ],
        "description": "Solution for Paper A Q1 - Bin Packing CSP Problem"
    },
    "Paper A - Amazon Amount Prediction": {
        "prefix": "amazon_amount",
        "body": [
            "import pandas as pd",
            "import numpy as np",
            "from sklearn.model_selection import train_test_split, cross_val_score, KFold",
            "from sklearn.preprocessing import StandardScaler, LabelEncoder, OneHotEncoder",
            "from sklearn.ensemble import RandomForestRegressor",
            "from sklearn.svm import SVR",
            "from sklearn.linear_model import LinearRegression",
            "from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error",
            "from sklearn.impute import SimpleImputer",
            "from sklearn.compose import ColumnTransformer",
            "from sklearn.pipeline import Pipeline",
            "",
            "def amazon_sale_regression():",
            "    # Part 1: Data Pre-processing",
            "    try:",
            "        df = pd.read_csv('amazon_sales.csv')",
            "    except FileNotFoundError:",
            "        print(\"Error: File 'amazon_sales.csv' not found\")",
            "        return",
            "    ",
            "    # Handle missing values",
            "    X = df.drop('Amount', axis=1)",
            "    y = df['Amount']",
            "    ",
            "    # Identify categorical and numerical columns",
            "    categorical_cols = X.select_dtypes(include=['object', 'category']).columns",
            "    numerical_cols = X.select_dtypes(include=['int64', 'float64']).columns",
            "    ",
            "    # Create preprocessing pipelines",
            "    numerical_transformer = Pipeline(steps=[",
            "        ('imputer', SimpleImputer(strategy='mean')),",
            "        ('scaler', StandardScaler())])",
            "    ",
            "    categorical_transformer = Pipeline(steps=[",
            "        ('imputer', SimpleImputer(strategy='most_frequent')),",
            "        ('onehot', OneHotEncoder(handle_unknown='ignore'))])",
            "    ",
            "    preprocessor = ColumnTransformer(",
            "        transformers=[",
            "            ('num', numerical_transformer, numerical_cols),",
            "            ('cat', categorical_transformer, categorical_cols)])",
            "    ",
            "    # Part 2: Data Splitting and Model Training",
            "    X_train, X_test, y_train, y_test = train_test_split(",
            "        X, y, test_size=0.2, random_state=42)",
            "    ",
            "    # Define models",
            "    models = {",
            "        'Random Forest': RandomForestRegressor(random_state=42),",
            "        'SVR': SVR(),",
            "        'Linear Regression': LinearRegression()",
            "    }",
            "    ",
            "    # Train and evaluate models",
            "    for name, model in models.items():",
            "        pipeline = Pipeline(steps=[('preprocessor', preprocessor),",
            "                                 ('model', model)])",
            "        pipeline.fit(X_train, y_train)",
            "        models[name] = pipeline",
            "    ",
            "    # Part 3: Model Evaluation",
            "    print(\"\\nTest Set Performance:\")",
            "    for name, model in models.items():",
            "        y_test_pred = model.predict(X_test)",
            "        print(f\"\\n{name}:\")",
            "        print(\"R² Score:\", r2_score(y_test, y_test_pred))",
            "        print(\"Mean Absolute Error:\", mean_absolute_error(y_test, y_test_pred))",
            "        print(\"Root Mean Squared Error:\", np.sqrt(mean_squared_error(y_test, y_test_pred)))",
            "    ",
            "    # Cross-validation",
            "    kfold = KFold(n_splits=5, shuffle=True, random_state=42)",
            "    for name, model in models.items():",
            "        cv_scores = cross_val_score(model, X, y, cv=kfold, scoring='r2')",
            "        print(f\"\\n{name} CV R²: {np.mean(cv_scores):.3f} (±{np.std(cv_scores):.3f})\")",
            "    ",
            "    return max(models.keys(), key=lambda x: r2_score(y_test, models[x].predict(X_test)))",
            "",
            "best_regressor = amazon_sale_regression()"
        ],
        "description": "Solution for Paper A Q2 - Amazon Amount Prediction"
    }
}